#include <avr/pgmspace.h>

// 64x64, 16-color paletted + RLE bitmap of Retro Stack Logo
// Storage format:
// - Palette: 16 x uint16_t (RGB565)
// - Data: RLE stream of bytes: [ (len-1)<<4 | colorIndex ] where len in [1..16]

#define RETRO_RLE_WIDTH 64
#define RETRO_RLE_HEIGHT 64
#define RETRO_RLE_PALETTE_SIZE 16

const uint16_t retro_stack_64x64_rle_palette[16] PROGMEM = {
    0xB69C, 0x8D17, 0x9A93, 0x5A92, 0x2AD2, 0xD132, 0x7970, 0x294C,
    0x10A8, 0x2889, 0x0888, 0x0888, 0x0888, 0x0087, 0x986E, 0x0047,
};

const uint8_t retro_stack_64x64_rle_data[] PROGMEM = {
    0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
    0xFB, 0xBB, 0x9A, 0xFB, 0x9B, 0xFB, 0x8B, 0x1A, 0xAD, 0x0B, 0x1A, 0xFB, 0x6B, 0xFB, 0x6B, 0x0A,
    0x0C, 0x1D, 0x19, 0x6E, 0x06, 0x09, 0x0B, 0x1D, 0x1A, 0xFB, 0x4B, 0xFB, 0x4B, 0x0A, 0x0C, 0x0D,
    0x08, 0x06, 0x0E, 0xB5, 0x0E, 0x09, 0x1D, 0x0A, 0xFB, 0x3B, 0xFB, 0x3B, 0x0A, 0x0D, 0x08, 0x0E,
    0xF5, 0x05, 0x0E, 0x09, 0x0D, 0x0C, 0x0A, 0xFB, 0x1B, 0xFB, 0x1B, 0x0A, 0x0B, 0x0D, 0x09, 0xF5,
    0x45, 0x0E, 0x0A, 0x0D, 0x0A, 0xFB, 0x0B, 0xFB, 0x0B, 0x0A, 0x0C, 0x0D, 0x0E, 0xF5, 0x75, 0x09,
    0x0D, 0x0A, 0xFB, 0xFB, 0x0A, 0x0C, 0x0A, 0x0E, 0xF5, 0x95, 0x09, 0x0D, 0x0A, 0xEB, 0xFB, 0x0C,
    0x0B, 0x0E, 0xF5, 0xB5, 0x09, 0x0D, 0x0A, 0xDB, 0xFB, 0x0D, 0x0E, 0x85, 0x13, 0x71, 0x32, 0x65,
    0x09, 0x0D, 0x0A, 0xCB, 0xDB, 0x0A, 0x0D, 0x06, 0x95, 0x54, 0x13, 0x21, 0x20, 0x75, 0xEB, 0xCB,
    0x0A, 0x0D, 0x09, 0x95, 0x02, 0x04, 0x03, 0x01, 0x33, 0x14, 0x01, 0x30, 0x02, 0x65, 0x06, 0x0D,
    0x0A, 0xBB, 0xCB, 0x0A, 0x0D, 0x0E, 0x95, 0x02, 0x04, 0x03, 0x51, 0x04, 0x01, 0x30, 0x01, 0x75,
    0x09, 0x0D, 0x0A, 0xAB, 0xBB, 0x0A, 0x0D, 0x09, 0xA5, 0x03, 0x04, 0x03, 0x51, 0x13, 0x30, 0x01,
    0x75, 0x06, 0x0D, 0x0A, 0xAB, 0xBB, 0x0A, 0x0D, 0x06, 0xA5, 0x03, 0x04, 0x03, 0x51, 0x13, 0x30,
    0x01, 0x85, 0x09, 0x0D, 0x0A, 0x9B, 0xAB, 0x0A, 0x0D, 0x09, 0xA5, 0x02, 0x14, 0x03, 0x51, 0x03,
    0x04, 0x40, 0x85, 0x06, 0x0D, 0x0A, 0x9B, 0xAB, 0x0A, 0x0D, 0x07, 0xA5, 0x02, 0x24, 0x13, 0x31,
    0x03, 0x04, 0x01, 0x30, 0x02, 0x75, 0x06, 0x0C, 0xAB, 0xAB, 0x0A, 0x0D, 0x06, 0x95, 0x02, 0x10,
    0x01, 0x03, 0x44, 0x03, 0x14, 0x01, 0x30, 0x01, 0x12, 0x65, 0x09, 0x0D, 0x0A, 0x8B, 0xBB, 0x0A,
    0x06, 0x72, 0x06, 0x02, 0x11, 0x40, 0x11, 0x03, 0x24, 0x01, 0x50, 0x02, 0x06, 0x32, 0x06, 0x02,
    0x09, 0x0D, 0x0A, 0x8B, 0x9B, 0x0A, 0x0D, 0x08, 0x96, 0x01, 0x04, 0x07, 0x14, 0x03, 0x11, 0x40,
    0x11, 0x50, 0x02, 0x66, 0x07, 0x0F, 0x0A, 0x8B, 0x9B, 0x0A, 0x0D, 0x09, 0x92, 0x00, 0x01, 0x03,
    0x04, 0x37, 0x14, 0x03, 0x01, 0x80, 0x72, 0x06, 0x0F, 0x0A, 0x8B, 0x9B, 0x0A, 0x0D, 0x09, 0x76,
    0x02, 0x21, 0x10, 0x11, 0x03, 0x14, 0x37, 0x14, 0x01, 0x40, 0x01, 0x66, 0x07, 0x0D, 0x0A, 0x8B,
    0x9B, 0x0A, 0x0D, 0x09, 0x66, 0x02, 0x01, 0x03, 0x09, 0x08, 0x09, 0x07, 0x01, 0x30, 0x11, 0x03,
    0x14, 0x07, 0x01, 0x40, 0x02, 0x66, 0x07, 0x0D, 0x0A, 0x8B, 0x9B, 0x0A, 0x0D, 0x09, 0x42, 0x06,
    0x02, 0x01, 0x03, 0x17, 0x03, 0x07, 0x03, 0x90, 0x11, 0x30, 0x01, 0x72, 0x06, 0x0F, 0x0A, 0x8B,
    0x9B, 0x0A, 0x0C, 0x08, 0x46, 0x01, 0x00, 0x01, 0x10, 0x01, 0x07, 0x03, 0x00, 0x31, 0xA0, 0x03,
    0x07, 0x76, 0x07, 0x0D, 0x0A, 0x8B, 0xAB, 0x0C, 0x08, 0x36, 0x03, 0x40, 0x01, 0x07, 0x10, 0x81,
    0x40, 0x03, 0x96, 0x07, 0x0D, 0x0A, 0x8B, 0xBB, 0x0C, 0x06, 0x42, 0x11, 0x70, 0x71, 0x20, 0x03,
    0x06, 0x92, 0x09, 0x0F, 0x0A, 0x8B, 0xAB, 0x0A, 0x0D, 0x09, 0x77, 0x03, 0x11, 0x80, 0x11, 0x10,
    0x01, 0x03, 0xB7, 0x0A, 0x0C, 0x9B, 0xAB, 0x0A, 0x0D, 0x09, 0x03, 0x16, 0x23, 0x26, 0x33, 0x11,
    0x70, 0x01, 0x03, 0x06, 0x13, 0x66, 0x13, 0x07, 0x0F, 0x0A, 0x9B, 0xBB, 0x0C, 0x0A, 0xF3, 0x03,
    0x11, 0x20, 0x01, 0xD3, 0x07, 0x0F, 0x0A, 0x9B, 0xCB, 0x0C, 0x08, 0xD9, 0x18, 0x17, 0x03, 0x01,
    0x03, 0xE9, 0xCB, 0xAB, 0x2A, 0x08, 0xF3, 0xF3, 0x23, 0x07, 0x0F, 0x0A, 0xAB, 0x9B, 0x0A, 0x0C,
    0x2F, 0x07, 0xF3, 0xF3, 0x03, 0x07, 0x1A, 0xBB, 0x8B, 0x0A, 0x0D, 0x09, 0x57, 0x0C, 0x08, 0xE7,
    0x09, 0x57, 0x08, 0x0A, 0x08, 0x0C, 0x07, 0x13, 0x07, 0x08, 0x0D, 0x0A, 0xAB, 0x8B, 0x0A, 0x0F,
    0x07, 0x51, 0x03, 0x0F, 0x61, 0x03, 0x61, 0x07, 0x51, 0x03, 0x0C, 0x0F, 0x03, 0x41, 0x09, 0x0D,
    0x0A, 0x9B, 0x8B, 0x0A, 0x0F, 0x07, 0x00, 0x31, 0x00, 0x01, 0x09, 0x01, 0x00, 0x41, 0x03, 0x10,
    0x21, 0x10, 0x03, 0x51, 0x00, 0x17, 0x51, 0x03, 0x0F, 0x0A, 0x9B, 0x8B, 0x0A, 0x0F, 0x07, 0x10,
    0x03, 0x08, 0x03, 0x10, 0x07, 0x01, 0x00, 0x01, 0x09, 0x17, 0x09, 0x07, 0x13, 0x01, 0x00, 0x01,
    0x13, 0x07, 0x01, 0x00, 0x03, 0x08, 0x03, 0x10, 0x07, 0x03, 0x10, 0x03, 0x07, 0x01, 0x00, 0x01,
    0x09, 0x0F, 0x0A, 0x8B, 0x8B, 0x0A, 0x0F, 0x07, 0x10, 0x07, 0x0F, 0x03, 0x10, 0x08, 0x01, 0x00,
    0x01, 0x0F, 0x1A, 0x0B, 0x2F, 0x01, 0x00, 0x03, 0x1F, 0x08, 0x10, 0x03, 0x0F, 0x07, 0x10, 0x03,
    0x01, 0x00, 0x01, 0x1F, 0x07, 0x10, 0x07, 0x0F, 0x0A, 0x8B, 0x8B, 0x0A, 0x0F, 0x07, 0x10, 0x11,
    0x20, 0x0F, 0x01, 0x40, 0x01, 0x0F, 0x08, 0x0A, 0x10, 0x01, 0x0F, 0x0A, 0x08, 0x20, 0x01, 0x20,
    0x07, 0x10, 0x03, 0x0F, 0x0B, 0x07, 0x10, 0x03, 0x0F, 0x0A, 0x8B, 0x8B, 0x0A, 0x0F, 0x07, 0x53,
    0x07, 0x0F, 0x43, 0x01, 0x03, 0x0F, 0x0C, 0x0A, 0x03, 0x01, 0x03, 0x0F, 0x0C, 0x08, 0x51, 0x03,
    0x08, 0x01, 0x00, 0x03, 0x0F, 0x0C, 0x07, 0x01, 0x00, 0x03, 0x0F, 0x0A, 0x8B, 0x8B, 0x0A, 0x0C,
    0x67, 0x1A, 0x27, 0x38, 0x0A, 0x0C, 0x08, 0x27, 0x0B, 0x0C, 0x08, 0x57, 0x0A, 0x08, 0x27, 0x1C,
    0x08, 0x27, 0x0C, 0x0A, 0x8B, 0x8B, 0x0A, 0x0F, 0x07, 0x14, 0x17, 0x14, 0x07, 0x0C, 0x24, 0x3F,
    0x1C, 0x08, 0x24, 0x1C, 0x08, 0x14, 0x17, 0x24, 0x08, 0x24, 0x0C, 0x0F, 0x07, 0x14, 0x07, 0x0F,
    0x0A, 0x8B, 0x8B, 0x0A, 0x0F, 0x07, 0x14, 0x07, 0x08, 0x24, 0x08, 0x64, 0x08, 0x0C, 0x08, 0x24,
    0x1C, 0x08, 0x24, 0x0C, 0x24, 0x08, 0x34, 0x07, 0x24, 0x08, 0x0C, 0x0A, 0x8B, 0x8B, 0x0A, 0x0F,
    0x07, 0x14, 0x07, 0x0F, 0x24, 0x07, 0x64, 0x07, 0x0F, 0x08, 0x24, 0x1C, 0x08, 0x24, 0x0F, 0x34,
    0x08, 0x64, 0x0C, 0x0A, 0x9B, 0x8B, 0x0A, 0x0F, 0x07, 0x14, 0x07, 0x0F, 0x07, 0x94, 0x07, 0x09,
    0x07, 0x24, 0x1C, 0x08, 0x24, 0x0F, 0x07, 0x24, 0x07, 0x02, 0x44, 0x08, 0x0C, 0x0A, 0x9B, 0x8B,
    0x0A, 0x0C, 0x08, 0x17, 0x08, 0x0F, 0x08, 0x57, 0x02, 0x55, 0x27, 0x08, 0x0B, 0x08, 0x27, 0x0C,
    0x0A, 0x17, 0x02, 0x05, 0x06, 0x08, 0x14, 0x07, 0x0A, 0x0C, 0x0A, 0xAB, 0x9B, 0x0A, 0x0C, 0x1F,
    0x0C, 0x0A, 0x0C, 0x4F, 0x0E, 0x05, 0x0E, 0x16, 0x12, 0x07, 0x09, 0x0E, 0x05, 0x2D, 0x2F, 0x0D,
    0x0F, 0x0D, 0x0E, 0x05, 0x07, 0x0F, 0x0C, 0x2F, 0x0C, 0x0A, 0xBB, 0xAB, 0x3A, 0x1B, 0x2A, 0x0D,
    0x07, 0x05, 0x06, 0x08, 0x0F, 0x0D, 0x09, 0x07, 0x25, 0x06, 0x09, 0x06, 0x05, 0x09, 0x0D, 0x07,
    0x06, 0x07, 0x0E, 0x05, 0x16, 0x08, 0x0B, 0x2A, 0xDB, 0xFB, 0x2B, 0x0A, 0x0C, 0x08, 0x06, 0x25,
    0x06, 0x0F, 0x07, 0x05, 0x06, 0x07, 0x35, 0x07, 0x45, 0x02, 0x15, 0x0A, 0x0C, 0xFB, 0x0B, 0xFB,
    0x2B, 0x1D, 0x1F, 0x0D, 0x08, 0x07, 0x05, 0x06, 0x02, 0x06, 0x08, 0x05, 0x16, 0x05, 0x06, 0x05,
    0x06, 0x09, 0x06, 0x05, 0x02, 0x16, 0x07, 0x0C, 0xFB, 0x1B, 0xFB, 0x0B, 0x0A, 0x0D, 0x07, 0x02,
    0x27, 0x06, 0x0E, 0x05, 0x02, 0x05, 0x06, 0x02, 0x05, 0x06, 0x15, 0x02, 0x05, 0x07, 0x06, 0x05,
    0x02, 0x15, 0x16, 0x0C, 0xFB, 0x1B, 0xFB, 0x0B, 0x0C, 0x0A, 0x65, 0x17, 0x05, 0x06, 0x09, 0x06,
    0x07, 0x06, 0x0E, 0x07, 0x0E, 0x05, 0x16, 0x0D, 0x06, 0x05, 0x07, 0x0F, 0xFB, 0x2B, 0xFB, 0x1B,
    0x0C, 0x08, 0x37, 0x08, 0x1D, 0x0C, 0x0A, 0x0D, 0x0F, 0x0D, 0x0F, 0x0C, 0x0D, 0x0F, 0x1D, 0x1F,
    0x0C, 0x1D, 0x0F, 0x0A, 0xFB, 0x2B, 0xFB, 0x2B, 0x0D, 0x1F, 0x0D, 0x0F, 0x0D, 0x0B, 0x0A, 0x1B,
    0x3A, 0x0B, 0x1A, 0x1B, 0x1A, 0x0B, 0x2A, 0xFB, 0x3B, 0xFB, 0x2B, 0x5A, 0xFB, 0xFB, 0x6B, 0xFB,
    0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
    0xFB, 0xFB, 0xFB,
};

// ---------- Small helpers ----------
// 16-bit read from PROGMEM (works on AVR; on non-AVR pgm_read_word usually maps to regular read)
static inline uint16_t pgm_read_u16(const void *addr) {
  return pgm_read_word(addr);
}

// Return the output height (in pixels) for source row r in [0..srcH-1],
// scaled to total dstH using pure integer math.
// This yields 3 or 4 for 320x240 from 64.
static uint8_t scaledRowHeight(uint16_t r, uint16_t srcH, uint16_t dstH) {
  uint16_t prev = (uint32_t)r * dstH / srcH;
  uint16_t next = (uint32_t)(r + 1) * dstH / srcH;
  return (uint8_t)(next - prev);  // 3 or 4 for 240/64
}

// Draw 64x64 paletted+RLE image scaled to exactly dstW x dstH,
// using filled rectangles (fast & blocky).
static void drawRLEPalettedScaledFill(Adafruit_GFX &gfx, int16_t x0, int16_t y0, uint16_t dstW,
                                      uint16_t dstH) {
  const uint16_t srcW = RETRO_RLE_WIDTH;   // 64
  const uint16_t srcH = RETRO_RLE_HEIGHT;  // 64
  const uint8_t scaleX = dstW / srcW;      // = 5 when 320x240
  const uint8_t scaleY_min = dstH / srcH;  // = 3 (but we vary between 3 and 4)

  (void)scaleY_min;  // only to quiet warnings if unused

  const uint8_t *p = retro_stack_64x64_rle_data;

  // Track source-space position to decide when we wrap rows.
  uint16_t srcX = 0;
  uint16_t srcY = 0;

  // Current destination cursor
  int16_t curX = x0;
  int16_t curY = y0;

  // Height of the current output row (3 or 4)
  uint8_t rowH = scaledRowHeight(srcY, srcH, dstH);

  // Process stream until we render all source pixels.
  const uint32_t totalSrc = (uint32_t)srcW * srcH;
  uint32_t drawnSrc = 0;

  while (drawnSrc < totalSrc) {
    uint8_t b = pgm_read_byte(p++);
    uint8_t len = (b >> 4) + 1;  // 1..16 pixels in source
    uint8_t ci = (b & 0x0F);     // palette index
    uint16_t color = pgm_read_u16(&retro_stack_64x64_rle_palette[ci]);

    while (len--) {
      // Width in destination pixels for this single source pixel
      uint16_t runW = scaleX;  // = 5 when 320 wide

      // Emit one filled rectangle for this single "pixel" in the run
      gfx.fillRect(curX, curY, runW, rowH, color);

      // Advance
      curX += runW;
      srcX++;
      drawnSrc++;

      // End of source row? wrap
      if (srcX >= srcW) {
        srcX = 0;
        srcY++;

        // advance destination Y by the row height and compute next row's height
        curY += rowH;
        rowH = (srcY < srcH) ? scaledRowHeight(srcY, srcH, dstH) : 0;
        curX = x0;
      }
    }
  }
}

void drawLogo(Adafruit_GFX &gfx, uint16_t width, uint16_t height) {
  gfx.fillScreen(0x000F);  // deep navy background

  // Scale the 64x64 source to exactly fill the display area.
  // For 320x240 this becomes 320x240 (5x horizontally, 3/4 vertically mixed).
  const int16_t x = 0;
  const int16_t y = 0;
  drawRLEPalettedScaledFill(gfx, x, y, width, height);
}
